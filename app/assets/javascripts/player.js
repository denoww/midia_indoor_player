// Generated by CoffeeScript 2.5.1
(function() {
  // player.coffee

  // Sentry.init
  //   dsn: 'https://ac78f87fac094b808180f86ad8867f61@sentry.io/1519364'
  //   integrations: [new Sentry.Integrations.Vue({Vue, attachProps: true})]

  // Sentry.configureScope (scope)->
  //   scope.setUser id: "TV_ID_#{process.env.TV_ID}_FRONTEND"

  // alert('2')
  var FORCE_BLOB_PLAYBACK, blobCache, data, descobrirTimezone, getContentType, injectSource, keyForUrl, mod, onLoaded, pendingBlobs, preAquecerCache, preAquecerImagem, preAquecerMidia, preAquecerSet, preAquecerVideo, reiniciando, relogio, restartBrowser, restartBrowserAposXSegundos, restartPlayerSeNecessario, timezoneGlobal, updateContent, updateOnlineStatus;

  timezoneGlobal = null;

  data = {
    body: void 0,
    loaded: false,
    loading: true,
    indexConteudoSuperior: 0,
    indexConteudoMensagem: 0,
    listaConteudoSuperior: [],
    listaConteudoMensagem: [],
    online: true,
    grade: {
      data: {
        cor: 'black',
        layout: 'layout-2',
        weather: {},
        logo: {}
      }
    }
  };

  onLoaded = function() {
    vm.loaded || (vm.loaded = gradeObj.loaded && feedsObj.loaded);
    if (vm.loaded) {
      vm.loading = false;
    }
    timelineConteudoSuperior.init();
    return timelineConteudoMensagem.init();
  };

  this.getTvId = function() {
    var params, tvId, uri;
    uri = window.location.search.substring(1);
    params = new URLSearchParams(uri);
    tvId = params.get("tvId");
    return tvId;
  };

  this.checkTv = function() {
    var error, success;
    success = (resp) => {
      data = resp.data;
      // console.log data
      return restartPlayerSeNecessario(data);
    };
    error = (resp) => {
      return console.log(resp);
    };
    return Vue.http.get('/check_tv?tvId=' + getTvId()).then(success, error);
  };

  // resto “sempre positivo”
  mod = function(a, b) {
    return ((a % b) + b) % b;
  };

  // === config flag ===
  // === flag
  // === config flag ===
  FORCE_BLOB_PLAYBACK = true;

  // caches
  blobCache = new Map(); // key -> { url, type, size }

  pendingBlobs = new Map(); // key -> Promise que resolve quando blob estiver pronto

  preAquecerSet = new Set();

  preAquecerCache = new Set();

  preAquecerVideo = function(url) {
    var key, p;
    if (url == null) {
      return;
    }
    key = keyForUrl(url);
    if (preAquecerSet.has(key) || blobCache.has(key)) {
      return;
    }
    preAquecerSet.add(key);
    if (FORCE_BLOB_PLAYBACK) {
      p = fetch(url, {
        mode: 'cors',
        credentials: 'omit',
        cache: 'force-cache'
      }).then(function(r) {
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }
        return Promise.all([r.arrayBuffer(), getContentType(r)]);
      }).then(function([buf, type]) {
        var blob, blobUrl;
        blob = new Blob([buf], {type});
        blobUrl = URL.createObjectURL(blob);
        blobCache.set(key, {
          url: blobUrl,
          type,
          size: buf.byteLength
        });
        console.log("blob pronto", key, blobUrl);
        return blobUrl;
      }).catch(function(e) {
        console.warn('preAquecerVideo(blob) falhou', url, e);
        preAquecerSet.delete(key);
        return null;
      });
      pendingBlobs.set(key, p);
      return p.finally(function() {
        return pendingBlobs.delete(key);
      });
    } else {
      return fetch(url, {
        mode: 'cors',
        credentials: 'omit',
        cache: 'force-cache'
      }).catch(function(e) {
        return preAquecerSet.delete(key);
      });
    }
  };

  // getPlayUrl = (item) ->
  //   return item?.arquivoUrl unless FORCE_BLOB_PLAYBACK and item?.is_video
  //   key = keyForUrl(item.arquivoUrl)
  //   cached = blobCache.get(key)
  //   cached?.url or item.arquivoUrl
  injectSource = function(v, url, type) {
    var s;
    while (v.firstChild != null) {
      v.removeChild(v.firstChild);
    }
    s = document.createElement('source');
    s.src = url;
    s.type = type || 'video/mp4';
    v.appendChild(s);
    return v.load();
  };

  preAquecerImagem = function(url) {
    var e, img;
    if (url == null) {
      return;
    }
    if (preAquecerCache.has(url)) {
      return;
    }
    preAquecerCache.add(url);
    fetch(url, {
      method: 'GET',
      mode: 'cors',
      credentials: 'omit',
      cache: 'force-cache'
    }).catch(function(e) {
      return preAquecerCache.delete(url);
    });
    try {
      // Fallback (também usa cache do navegador)
      img = new Image();
      img.decoding = 'async';
      img.referrerPolicy = 'no-referrer';
      return img.src = url;
    } catch (error1) {
      e = error1;
      return null;
    }
  };

  preAquecerMidia = function(item) {
    if (item == null) {
      return;
    }
    if (item.is_video && item.arquivoUrl) {
      return preAquecerVideo(item.arquivoUrl);
    } else if (item.is_image && item.arquivoUrl) {
      return preAquecerImagem(item.arquivoUrl);
    }
  };

  // === helpers de URL/cache ===
  keyForUrl = function(u) {
    var e, url;
    try {
      url = new URL(u, window.location.href);
      // mesma origem, mesmo path; ignora search e hash
      return `${url.origin}${url.pathname}`;
    } catch (error1) {
      e = error1;
      // fallback bruto
      return (u.split('?')[0] || u).split('#')[0];
    }
  };

  getContentType = function(resp) {
    var ref;
    return (resp != null ? (ref = resp.headers) != null ? ref.get('Content-Type') : void 0 : void 0) || 'video/mp4';
  };

  this.gradeObj = {
    tentar: 10,
    tentativas: 0,
    restart_player_em: null,
    get: function(onSuccess, onError) {
      var error, success;
      if (this.loading) {
        return;
      }
      this.loading = true;
      success = (resp) => {
        if (this.tentativas > 0) {
          restartBrowserAposXSegundos(30);
        }
        this.loading = false;
        this.tentativas = 0;
        this.handle(resp.data);
        if (typeof onSuccess === "function") {
          onSuccess();
        }
        this.mountWeatherData();
        this.loaded = true;
        return onLoaded();
      };
      error = (resp) => {
        this.loading = false;
        onLoaded();
        console.error('Grade:', resp);
        this.tentativas++;
        if (this.tentativas > this.tentar) {
          console.error('Grade: Não foi possível comunicar com o servidor!');
          return;
        }
        this.tentarNovamenteEm = 1000 * this.tentativas;
        console.warn(`Grade: Tentando em ${this.tentarNovamenteEm / 1000} segundos`);
        setTimeout(function() {
          return gradeObj.get();
        }, this.tentarNovamenteEm);
        return typeof onError === "function" ? onError() : void 0;
      };
      Vue.http.get('/grade?tvId=' + getTvId()).then(success, error);
    },
    downloadNewContent: function() {
      var error, success;
      success = (resp) => {
        return this.get(function() {
          return console.log("Novo Conteúdo baixado");
        });
      };
      error = (resp) => {
        return console.log(resp);
      };
      return Vue.http.get('/download_new_content?tvId=' + getTvId()).then(success, error);
    },
    handle: function(data) {
      this.restart_player_em = data.restart_player_em;
      vm.grade.data = this.data = data;
    },
    mountWeatherData: function() {
      var base, dataHoje, dia, mes;
      (base = vm.grade.data).weather || (base.weather = {});
      if (!(vm.grade.data.weather.proximos_dias || []).length) {
        return;
      }
      dataHoje = new Date();
      dia = `${dataHoje.getDate()}`.rjust(2, '0');
      mes = `${dataHoje.getMonth() + 1}`.rjust(2, '0');
      dataHoje = `${dia}/${mes}`;
      dia = vm.grade.data.weather.proximos_dias[0];
      if (dia.data === dataHoje) {
        dia = vm.grade.data.weather.proximos_dias.shift();
        vm.grade.data.weather.max = dia.max;
        vm.grade.data.weather.min = dia.min;
      }
      vm.grade.data.weather.proximos_dias = vm.grade.data.weather.proximos_dias.slice(0, 4);
    }
  };

  this.feedsObj = {
    data: {},
    tentar: 10,
    tentativas: 0,
    posicoes: ['conteudo_superior', 'conteudo_mensagem'],
    get: function(onSuccess, onError) {
      var error, success;
      if (this.loading) {
        return;
      }
      this.loading = true;
      success = (resp) => {
        this.loading = false;
        this.tentativas = 0;
        this.handle(resp.data);
        this.verificarNoticias();
        if (typeof onSuccess === "function") {
          onSuccess();
        }
        this.loaded = true;
        return onLoaded();
      };
      error = (resp) => {
        this.loading = false;
        onLoaded();
        console.error('Feeds:', resp);
        this.tentativas++;
        if (this.tentativas > this.tentar) {
          console.error('Feeds: Não foi possível comunicar com o servidor!');
          return;
        }
        this.tentarNovamenteEm = 1000 * this.tentativas;
        console.warn(`Feeds: Tentando em ${this.tentarNovamenteEm / 1000} segundos`);
        setTimeout((function() {
          return feedsObj.get();
        }), this.tentarNovamenteEm);
        return typeof onError === "function" ? onError() : void 0;
      };
      Vue.http.get('/feeds?tvId=' + getTvId()).then(success, error);
    },
    handle: function(data) {
      var base, base1, base2, base3, feed, feeds, i, l, len, len1, name, name1, posicao, ref;
      this.data = data;
      ref = this.posicoes;
      // pre-montar a estrutura dos feeds com base na grade para ser usado em verificarNoticias()
      for (i = 0, len = ref.length; i < len; i++) {
        posicao = ref[i];
        (base = vm.grade.data)[posicao] || (base[posicao] = []);
        feeds = (typeof (base1 = vm.grade.data[posicao]).select === "function" ? base1.select(function(e) {
          return e.tipo_midia === 'feed';
        }) : void 0) || [];
        for (l = 0, len1 = feeds.length; l < len1; l++) {
          feed = feeds[l];
          (base2 = this.data)[name = feed.fonte] || (base2[name] = {});
          (base3 = this.data[feed.fonte])[name1 = feed.categoria] || (base3[name1] = []);
        }
      }
    },
    verificarNoticias: function() {
      var base, base1, categoria, categorias, fonte, i, item, items, l, len, len1, noticias, posicao, ref, ref1, ref2;
      ref = this.data;
      // serve para remover feeds que nao tem noticias
      for (fonte in ref) {
        categorias = ref[fonte];
        for (categoria in categorias) {
          noticias = categorias[categoria];
          if ((noticias || []).empty()) {
            ref1 = this.posicoes;
            for (i = 0, len = ref1.length; i < len; i++) {
              posicao = ref1[i];
              if (!vm.grade.data[posicao]) {
                continue;
              }
              (base = vm.grade.data)[posicao] || (base[posicao] = []);
              items = typeof (base1 = vm.grade.data[posicao]).select === "function" ? base1.select(function(e) {
                return e.fonte === fonte && e.categoria === categoria;
              }) : void 0;
              ref2 = items || [];
              for (l = 0, len1 = ref2.length; l < len1; l++) {
                item = ref2[l];
                vm.grade.data[posicao].removeById(item.id);
              }
            }
          }
        }
      }
    }
  };

  this.timelineConteudoSuperior = {
    promessa: null,
    nextIndex: 0,
    feedIndex: {},
    playlistIndex: {},
    ultimoVideo: null,
    playTimer1: null,
    playTimer2: null,
    init: function() {
      if (!vm.loaded) {
        return;
      }
      if (this.promessa == null) {
        return this.executar();
      }
    },
    // =============== Núcleo unificado ===============

    // Resolve o item da faixa superior no índice atual.
    // opts:
    //   consuming: true/false  -> avança índices?
    //   offset:    inteiro     -> 0 = atual, 1 = próximo, 2 = +2, ...
    resolveNextItem: function(opts = {
        consuming: true,
        offset: 0
      }) {
      var idxLista, item, lista, raw, ref, varOffset;
      lista = vm.grade.data.conteudo_superior || [];
      if (!lista.length) {
        return null;
      }
      varOffset = (ref = opts.offset) != null ? ref : 0;
      idxLista = mod(this.nextIndex + varOffset, lista.length);
      raw = lista[idxLista];
      item = this.resolveItem(raw, opts);
      if (!item) {
        return null;
      }
      if (opts.consuming && varOffset === 0) {
        // só consome quando offset é 0 (o "agora")
        this.nextIndex = mod(this.nextIndex + 1, lista.length);
      }
      return item;
    },
    // Resolve um item: simples, feed ou playlist
    resolveItem: function(rawItem, opts) {
      if (rawItem == null) {
        return null;
      }
      switch (rawItem != null ? rawItem.tipo_midia : void 0) {
        case 'feed':
          return this.resolveFeedItem(rawItem, opts);
        case 'playlist':
          return this.resolvePlaylistItem(rawItem, opts);
        default:
          return rawItem; // midia/informativo/mensagem etc.
      }
    },
    
    // Feed com índice por (fonte,categoria), id estável
    resolveFeedItem: function(rawItem, opts = {}) {
      var base, categ, feed, feeds, fonte, idx, item, ref, ref1;
      fonte = rawItem.fonte;
      categ = rawItem.categoria;
      feeds = ((ref = feedsObj.data[fonte]) != null ? ref[categ] : void 0) || [];
      if (!feeds.length) {
        return null;
      }
      if ((base = this.feedIndex)[fonte] == null) {
        base[fonte] = {};
      }
      idx = this.feedIndex[fonte][categ];
      if (!Number.isInteger(idx)) {
        idx = 0;
      }
      feed = feeds[Math.min(idx, feeds.length - 1)];
      if (!feed) {
        return null;
      }
      item = Object.assign({}, rawItem);
      item.id = `feed-${fonte}-${categ}`;
      item.data = feed.data;
      item.qrcode = feed.qrcode;
      item.titulo = feed.titulo;
      item.titulo_feed = feed.titulo_feed;
      item.categoria_feed = feed.categoria_feed;
      item.nome_arquivo = feed.nome_arquivo;
      item.arquivoUrl = (ref1 = feed.arquivoUrl) != null ? ref1 : feed.filePath;
      if (opts.consuming) {
        this.feedIndex[fonte][categ] = mod(idx + 1, feeds.length);
      }
      return item;
    },
    // Playlist mantém um índice por playlist.id
    resolvePlaylistItem: function(playlist, opts = {}) {
      var base, cand, contentSup, idx, name;
      contentSup = playlist.conteudo_superior || [];
      if (!contentSup.length) {
        return null;
      }
      if ((base = this.playlistIndex)[name = playlist.id] == null) {
        base[name] = 0;
      }
      idx = this.playlistIndex[playlist.id];
      if (!Number.isInteger(idx)) {
        idx = 0;
      }
      cand = contentSup[Math.min(idx, contentSup.length - 1)];
      if (opts.consuming) {
        this.playlistIndex[playlist.id] = mod(idx + 1, contentSup.length);
      }
      if ((cand != null ? cand.tipo_midia : void 0) !== 'feed') {
        return cand;
      }
      // se o item da playlist for feed, resolve via feed (sem consumir duas vezes)
      // Passa consuming do call original (para avançar feedIndex somente se consumir)
      return this.resolveFeedItem(cand, opts);
    },
    // Apenas olha o próximo sem avançar índices
    peekNextItem: function() {
      return this.resolveNextItem({
        consuming: false,
        offset: 1
      });
    },
    // =============== Loop ===============
    executar: function() {
      var cand, i, itemAtual, k, preaquecerQtdMidiasAFrente, ref, segundos;
      if (this.promessa) {
        clearTimeout(this.promessa);
      }
      itemAtual = this.resolveNextItem({
        consuming: true
      });
      if (!itemAtual) {
        return console.error("resolveNextItem() retornou null");
      }
      // Mantém SOMENTE o atual no v-for
      vm.listaConteudoSuperior = [itemAtual];
      vm.indexConteudoSuperior = 0;
      this.stopUltimoVideo();
      // agenda próximo ciclo
      segundos = (itemAtual.segundos * 1000) || 5000;
      this.promessa = setTimeout((function() {
        return timelineConteudoSuperior.executar();
      }), segundos);
      // Pré-aquecer N itens à frente (vídeo ou imagem)
      // preaquecerQtdMidiasAFrente = 2
      preaquecerQtdMidiasAFrente = 1;
      console.log(`preaquecer proximos video/imagem qtd: ${preaquecerQtdMidiasAFrente}`);
      for (k = i = 1, ref = preaquecerQtdMidiasAFrente; (1 <= ref ? i <= ref : i >= ref); k = 1 <= ref ? ++i : --i) {
        cand = this.resolveNextItem({
          consuming: false,
          offset: k
        });
        // console.log cand
        if ((cand != null ? cand.arquivoUrl : void 0) && (cand.is_video || cand.is_image)) {
          preAquecerMidia(cand);
        }
      }
      if (itemAtual.is_video) {
        // Toca o atual (se for vídeo)
        this.playVideo(itemAtual);
      }
    },
    // =============== Vídeo ===============

    // playVideo injeta a <source> dinâmica
    // =============== Vídeo ===============
    playVideo: function(itemAtual) {
      var chooseAndPlay, key, pend;
      this.ultimoVideo = `video-player-${itemAtual.id}`;
      if (this.playTimer1 != null) {
        clearTimeout(this.playTimer1);
      }
      if (this.playTimer2 != null) {
        clearTimeout(this.playTimer2);
      }
      key = keyForUrl(itemAtual.arquivoUrl);
      pend = pendingBlobs.get(key);
      chooseAndPlay = (v) => {
        var ctype, entry, finalUrl;
        entry = blobCache.get(key);
        finalUrl = FORCE_BLOB_PLAYBACK && (entry != null ? entry.url : void 0) ? entry.url : itemAtual.arquivoUrl;
        ctype = (entry != null ? entry.type : void 0) || itemAtual.content_type || 'video/mp4';
        injectSource(v, finalUrl, ctype);
        v.currentTime = 0;
        return v.play().catch(function(e) {
          return console.warn('play falhou', e);
        });
      };
      this.playTimer1 = setTimeout(() => {
        var v;
        v = document.getElementById(this.ultimoVideo);
        if (v == null) {
          return;
        }
        // Se existir um blob pendente, aguarda até 10s; usa blob somente se ficar pronto.
        if (FORCE_BLOB_PLAYBACK && (pend != null) && (blobCache.get(key) == null)) {
          return Promise.race([
            pend.then(function() {
              return 'ok';
            }),
            new Promise(function(res) {
              return setTimeout((function() {
                return res('timeout');
              }),
            10000);
            })
          ]).finally(() => {
            return chooseAndPlay(v); // se blob não existir ainda, cairá na URL original
          });
        } else {
          return chooseAndPlay(v);
        }
      }, 0);
      this.playTimer2 = setTimeout(() => {
        var v;
        v = document.getElementById(this.ultimoVideo);
        return (v != null ? v.paused : void 0) && v.play().catch(function(e) {
          return console.warn('replay falhou', e);
        });
      }, 1000);
    },
    // revoga blob ao parar, eliminando vazamento e caches velhos
    // NÃO remove nem revoga blob do cache: apenas pausa e limpa o <video>
    stopUltimoVideo: function() {
      var e, v;
      if (!this.ultimoVideo) {
        return;
      }
      v = document.getElementById(this.ultimoVideo);
      if (v != null) {
        try {
          v.pause();
        } catch (error1) {
          e = error1;
          null;
        }
        try {
          v.removeAttribute('src');
          while (v.firstChild != null) {
            v.removeChild(v.firstChild); // remove <source>
          }
          v.load(); // desaloca o decoder sem mexer no blobCache
        } catch (error1) {
          e = error1;
          null;
        }
      }
      this.ultimoVideo = null;
      if (this.playTimer1 != null) {
        clearTimeout(this.playTimer1);
      }
      if (this.playTimer2 != null) {
        clearTimeout(this.playTimer2);
      }
      this.playTimer1 = this.playTimer2 = null;
    }
  };

  // @timelineConteudoSuperior =
  //   promessa:  null
  //   nextIndex: 0
  //   feedIndex: {}
  //   playlistIndex: {}
  //   init: ->
  //     return unless vm.loaded
  //     @executar() unless @promessa?
  //   executar: ->
  //     clearTimeout @promessa if @promessa

  //     itemAtual = @getNextItemConteudoSuperior()
  //     return console.error "@getNextItemConteudoSuperior() - itemAtual é indefinido!", itemAtual unless itemAtual

  //     vm.indexConteudoSuperior = vm.listaConteudoSuperior.getIndexByField 'id', itemAtual.id
  //     if !vm.indexConteudoSuperior?

  //       # console.log itemAtual
  //       vm.listaConteudoSuperior = [itemAtual] # mantém a lista com *apenas* o item atual
  //       vm.indexConteudoSuperior = 0

  //       # vm.listaConteudoSuperior.push itemAtual
  //       # vm.indexConteudoSuperior = vm.listaConteudoSuperior.length - 1

  //     @stopUltimoVideo()

  //     segundos = (itemAtual.segundos * 1000) || 5000
  //     @promessa = setTimeout ->
  //       timelineConteudoSuperior.executar()
  //     , segundos

  //     @playVideo(itemAtual) if itemAtual.is_video
  //     return
  //   playVideo: (itemAtual)->
  //     @ultimoVideo = "video-player-#{itemAtual.id}"

  //     clearTimeout(@playTimer1) if @playTimer1?
  //     clearTimeout(@playTimer2) if @playTimer2?

  //     getUltimoVideo = -> document.getElementById(@ultimoVideo)

  //     @playTimer1 = setTimeout =>
  //       v = getUltimoVideo()
  //       if v?
  //         v.currentTime = 0
  //         v.play().catch((e)-> console.warn('play falhou', e))
  //     , 0

  //     @playTimer2 = setTimeout =>
  //       v = getUltimoVideo()
  //       if v?.paused
  //         v.play().catch((e)-> console.warn('replay falhou', e))
  //     , 1000
  //     return

  //   # playVideo: (itemAtual)->
  //   #   @ultimoVideo = "video-player-#{itemAtual.id}"

  //   #   setTimeout =>
  //   #     video = document.getElementById(@ultimoVideo)
  //   #     if video
  //   #       video.currentTime = 0
  //   #       video.play()

  //   #   setTimeout =>
  //   #     video = document.getElementById(@ultimoVideo)
  //   #     video.play() if video?.paused
  //   #   , 1000
  //   #   return
  //   stopUltimoVideo: ->
  //     videoId = @ultimoVideo
  //     return unless videoId

  //     v = document.getElementById(videoId)
  //     if v?
  //       try v.pause() catch e then null
  //       try
  //         # remove src/source para liberar decoder/buffer
  //         v.removeAttribute('src')
  //         while v.firstChild?
  //           v.removeChild(v.firstChild) # remove <source>
  //         v.load()  # força desalocar
  //       catch e then null
  //     @ultimoVideo = null

  //     # limpa timers de play (ver D)
  //     clearTimeout(@playTimer1) if @playTimer1?
  //     clearTimeout(@playTimer2) if @playTimer2?
  //     @playTimer1 = @playTimer2 = null
  //     return

  //   # stopUltimoVideo: ->
  //   #   videoId = @ultimoVideo
  //   #   return unless videoId

  //   #   video = document.getElementById(videoId)
  //   #   video.pause() if video
  //   #   @ultimoVideo = null
  //   #   return
  //   getNextItemConteudoSuperior: ->
  //     lista = vm.grade.data.conteudo_superior || []
  //     listaQtd = lista.length
  //     return console.error "vm.grade.data.conteudo_superior está vazio!", lista unless listaQtd

  //     index = @nextIndex
  //     index = 0 if index >= listaQtd

  //     @nextIndex++
  //     @nextIndex = 0 if @nextIndex >= listaQtd

  //     currentItem = lista[index]
  //     switch currentItem?.tipo_midia
  //       when 'feed'
  //         currentItem = @getItemFeed(currentItem)
  //       when 'playlist'
  //         currentItem = @getItemPlaylist(currentItem)
  //         if !currentItem && listaQtd > 1
  //           currentItem = @getNextItemConteudoSuperior()

  //     currentItem
  //   getItemFeed: (currentItem)->
  //     feedItems = feedsObj.data[currentItem.fonte]?[currentItem.categoria] || []
  //     if feedItems.empty()
  //       console.warn "Feeds de #{currentItem.fonte} #{currentItem.categoria} está vazio"
  //       timelineConteudoSuperior.promessa = setTimeout ->
  //         timelineConteudoSuperior.executar()
  //       , 2000
  //       return

  //     fonte = currentItem.fonte
  //     categ = currentItem.categoria
  //     @feedIndex[fonte] ||= {}

  //     if !@feedIndex[fonte][categ]?
  //       @feedIndex[fonte][categ] = 0
  //     else
  //       @feedIndex[fonte][categ]++

  //     if @feedIndex[fonte][categ] >= feedItems.length
  //       @feedIndex[fonte][categ] = 0

  //     index = @feedIndex[fonte][categ]
  //     feed = feedItems[index] || feedItems[0]

  //     return unless feed
  //     currentItem.id     = "#{currentItem.id}#{feed.nome_arquivo}"
  //     currentItem.data   = feed.data
  //     currentItem.qrcode = feed.qrcode
  //     currentItem.titulo = feed.titulo
  //     currentItem.titulo_feed = feed.titulo_feed
  //     currentItem.categoria_feed = feed.categoria_feed
  //     currentItem.nome_arquivo = feed.nome_arquivo
  //     currentItem.filePath = feed.filePath
  //     currentItem
  //   getItemPlaylist: (playlist)->
  //     contentSup = playlist.conteudo_superior || []
  //     if !@playlistIndex[playlist.id]?
  //       @playlistIndex[playlist.id] = 0
  //     else
  //       @playlistIndex[playlist.id]++

  //     if @playlistIndex[playlist.id] >= contentSup.length
  //       @playlistIndex[playlist.id] = 0

  //     currentItem = contentSup[@playlistIndex[playlist.id]]

  //     return currentItem if currentItem?.tipo_midia != 'feed'
  //     @getItemFeed(currentItem)
  this.timelineConteudoMensagem = {
    promessa: null,
    nextIndex: 0,
    playlistIndex: {},
    init: function() {
      if (!vm.loaded) {
        return;
      }
      if (this.promessa == null) {
        return this.executar();
      }
    },
    executar: function() {
      var itemAtual, segundos;
      if (this.promessa) {
        clearTimeout(this.promessa);
      }
      itemAtual = this.getNextItemMsg();
      if (!itemAtual) {
        return;
      }
      vm.indexConteudoMensagem = vm.listaConteudoMensagem.getIndexByField('id', itemAtual.id);
      if (vm.indexConteudoMensagem == null) {
        vm.listaConteudoMensagem.push(itemAtual);
        vm.indexConteudoMensagem = vm.listaConteudoMensagem.length - 1;
      }
      segundos = (itemAtual.segundos * 1000) || 5000;
      this.promessa = setTimeout(function() {
        return timelineConteudoMensagem.executar();
      }, segundos);
    },
    getNextItemMsg: function() {
      var currentItem, index, lista, total;
      lista = vm.grade.data.conteudo_mensagem || [];
      total = lista.length;
      if (!total) {
        return;
      }
      index = this.nextIndex;
      if (index >= total) {
        index = 0;
      }
      this.nextIndex++;
      if (this.nextIndex >= total) {
        this.nextIndex = 0;
      }
      currentItem = lista[index];
      switch (currentItem != null ? currentItem.tipo_midia : void 0) {
        case 'feed':
          return this.getItemFeed(currentItem);
        default:
          return currentItem;
      }
    },
    getItemFeed: function(currentItem) {
      var feed, feedItems, index, ref;
      feedItems = ((ref = feedsObj.data[currentItem.fonte]) != null ? ref[currentItem.categoria] : void 0) || [];
      if (feedItems.empty()) {
        return currentItem;
      }
      index = parseInt(Math.random() * 100) % feedItems.length;
      feed = feedItems[index] || feedItems[0];
      if (!feed) {
        return;
      }
      currentItem.id = `${currentItem.id}${feed.titulo}`;
      currentItem.data = feed.data;
      currentItem.qrcode = feed.qrcode;
      currentItem.titulo = feed.titulo;
      currentItem.titulo_feed = feed.titulo_feed;
      currentItem.categoria_feed = feed.categoria_feed;
      currentItem.filePath = feed.filePath;
      return currentItem;
    }
  };

  descobrirTimezone = function(callback) {
    var done, e, tz;
    // fallback em caso de erro
    done = function(tz) {
      timezoneGlobal = tz || "America/Sao_Paulo";
      return typeof callback === "function" ? callback(timezoneGlobal) : void 0;
    };
    try {
      tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      if (tz) {
        return done(tz);
      }
    } catch (error1) {
      e = error1;
      console.warn("Intl timezone falhou:", e);
    }
    return fetch('http://ip-api.com/json').then(function(r) {
      return r.json();
    }).then(function(j) {
      if (j != null ? j.timezone : void 0) {
        return done(j.timezone);
      } else {
        throw new Error("timezone não encontrado");
      }
    }).catch(function() {
      return fetch('https://worldtimeapi.org/api/ip').then(function(r) {
        return r.json();
      }).then(function(j) {
        return done(j != null ? j.timezone : void 0);
      }).catch(function(e) {
        console.warn("Falha ao detectar timezone:", e);
        return done("America/Sao_Paulo");
      });
    });
  };

  // descobrirTimezone = (callback) ->
  //   console.log "Descobrindo timezone..."

  //   timezone = 'America/Sao_Paulo'
  //   error = ->
  //     console.log 'erro em descobrirTimezone'
  //     callback(timezone)
  //   success = (resp)=>
  //     success = resp.status == 200
  //     if success
  //       data = resp.data
  //       timezone = data.timezone
  //     callback(timezone)

  //   url = 'http://ip-api.com/json'
  //   Vue.http.get(url).then success, error
  relogio = {
    exec: function() {
      return descobrirTimezone(function(timezone) {
        var hour, min, now;
        console.log(`Timezone: ${timezone}`);
        // now = moment.tz(new Date, 'America/Los_Angeles');
        now = moment.tz(new Date(), timezone);
        hour = now.get('hour');
        min = now.get('minute');
        if (hour < 10) {
          // hour = now.get('hour')
          // min  = now.get('minute')
          // sec  = now.getSeconds()
          hour = `0${hour}`;
        }
        if (min < 10) {
          min = `0${min}`;
        }
        // sec  = "0#{sec}"  if sec < 10
        this.elemHora || (this.elemHora = document.getElementById('hora'));
        if (this.elemHora) {
          this.elemHora.innerHTML = hour + ':' + min;
        }
        return this.timer = setTimeout(relogio.exec, 1000 * 60); // 1 minuto
      });
    }
  };

  // @elemHora.innerHTML = hour + ':' + min + ':' + sec if @elemHora
  // setTimeout relogio.exec, 1000
  updateOnlineStatus = function() {
    var old, passouDeOfflineParaOnline;
    if (!this.vm) {
      return;
    }
    if (this.vm.loading) {
      return;
    }
    old = vm.online;
    vm.online = navigator.onLine;
    passouDeOfflineParaOnline = old !== vm.online && vm.online;
    if (passouDeOfflineParaOnline) {
      return this.gradeObj.downloadNewContent();
    }
  };

  // alert('entrou')
  updateContent = function() {
    if (!this.vm) {
      return;
    }
    // return if @vm.loading
    return gradeObj.get(function() {
      return feedsObj.get(function() {
        vm.loading = false;
        return vm.loaded = true;
      });
    });
  };

  window.addEventListener('online', updateOnlineStatus);

  window.addEventListener('offline', updateOnlineStatus);

  this.vm = new Vue({
    el: '#main-player',
    data: data,
    methods: {
      playVideo: timelineConteudoSuperior.playVideo,
      mouse: function() {
        if (this.mouseTimeout) {
          clearTimeout(this.mouseTimeout);
        }
        this.body || (this.body = document.getElementById('body-player'));
        this.body.style.cursor = 'default';
        return this.mouseTimeout = setTimeout(() => {
          return this.body.style.cursor = 'none';
        }, 1000);
      }
    },
    computed: {
      now: function() {
        return Date.now();
      }
    },
    mounted: function() {
      this.loading = true;
      this.mouse();
      relogio.exec();
      setInterval(function() {
        // return if vm.loaded
        return checkTv();
      }, 1000 * 3); // 3 segundo
      setTimeout(function() {
        if (vm.loaded) {
          return;
        }
        return updateContent();
      }, 1000 * 1); // 1 segundo
      setInterval(function() {
        updateContent();
        return updateOnlineStatus();
      // , 1000 * 2 # a cada 2 minutos
      }, 1000 * 60 * 2); // a cada 2 minutos
    }
  });

  Vue.filter('formatDayMonth', function(value) {
    if (value) {
      return moment(value).format('DD MMM');
    }
  });

  Vue.filter('formatDate', function(value) {
    if (value) {
      return moment(value).format('DD/MM/YYYY');
    }
  });

  Vue.filter('formatDateTime', function(value) {
    if (value) {
      return moment(value).format('DD/MM/YYYY HH:mm');
    }
  });

  Vue.filter('formatWeek', function(value) {
    if (value) {
      return moment(value).format('dddd');
    }
  });

  Vue.filter('currency', function(value) {
    return (value || 0).toLocaleString('pt-Br', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  });

  restartBrowser = function() {
    return window.location.reload();
  };

  reiniciando = false;

  restartBrowserAposXSegundos = function(xSegundos) {
    if (reiniciando) {
      return;
    }
    reiniciando = true;
    console.log(`Será reiniciado em ${xSegundos} segundos`);
    return setTimeout(() => {
      return restartBrowser();
    }, xSegundos * 1000);
  };

  restartPlayerSeNecessario = function(data) {
    // xSegundos = data.restart_player_em_x_segundos
    // return unless xSegundos

    // console.log 'gradeObj.restart_player_em'
    // console.log gradeObj.restart_player_em
    // console.log 'data.restart_player_em'
    // console.log data.restart_player_em
    if (data.restart_player_em !== gradeObj.restart_player_em) {
      return restartBrowserAposXSegundos(20);
    }
  };

  // @timers = []
// @timers.push = setTimeout => @exec(), 2000

}).call(this);
